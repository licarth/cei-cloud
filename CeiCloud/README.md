Introduction
------------

CeiCloud is a Sup√©lec IT department project. Designed for experiments detailed in paper release [Bin packing algorithms applied to load balancing in a cloud environment](link!), this project is a framework to describe problems, implement several algorithms to solve these problems and compare their relative precision.

This framework covers :
*	Problem definitions
*	Instance definitions
*	Generation of instances of those problems
*	Algorithms definitions (for a certain problem)
*	Benchmarks to compare algorithms

This formalism has been defined in order to be used in paper realease mentioned above.

Build
-----

This project relies on Maven dependency management. The easiest way to import dependencies and build is to use Maven.


To do
----

To make this tool more complete, we could :

*	Enhance benchmarking classes (benckmark package) to automatically compare algorithm precision and output the results in a particular form
*	Create 
*	Use a logging API (instead of System.out.print!)

Authors & Contributors
-------

[Thomas Carli](mailto:thomascarli@gmail.com)

Examples
--------

Although this tool has been developped to evaluate the precision of VSCIFP problems defined in the paper release mentioned in the introduction, one can define its own Problem, Instances, Algorithms and Generators.

Let's run through a simple example. Let's say we are trying to assess the precision of Bin Packing Algorithms. The following snippet is printing one by one the precision of differrent BPP algorithms, run on 10 instances generated by a UniformBPPGenerator. This generator focuses on creating 200 items of size uniformly chosen between 1 and 10. We don't know the optimal cost of those instances.

```java

		BPP bpp = new BPP(10);		//	Problem declaration with a max bin size parameter of 10.

		FFD ffd = new FFD();		//	Algorithms declarations
		FF ff = new FF();
		NF nf = new NF();
		NFD nfd = new NFD();

		UniformBPPGenerator gen = new UniformBPPGenerator(bpp, 200);					//	Instance generator declaration

		List<BPPInstance> l = gen.generateInstances(3);
		for (BPPInstance iBpp : l) {
			BPPSol ffSol = ff.solve(iBpp);		//	Solves current instance with First-Fit algorithm.
			BPPSol ffdSol = ffd.solve(iBpp);
			BPPSol nfSol = nf.solve(iBpp);
			BPPSol nfdSol = nfd.solve(iBpp);

			System.out.println(ffSol);			//	Prints solutions & costs
			System.out.println(ffdSol);
			System.out.println(nfSol);
			System.out.println(nfdSol);
		}
```

Output : 

```
FF, Cost : 118
FFD, Cost : 116
NF, Cost : 140
NFD, Cost : 137

FF, Cost : 119
FFD, Cost : 113
NF, Cost : 143
NFD, Cost : 134

FF, Cost : 112
FFD, Cost : 108
NF, Cost : 137
NFD, Cost : 129
```

Same example with a generator that is aware of optimal costs of instances that it generates. Here we use the instances from a library found on the web : [Marthello & Toth instances Dataset 1](http://www.wiwi.uni-jena.de/entscheidung/binpp/bin1dat.htm).

```java
	BPP bpp = new BPP(10);		//	Problem declaration with a max bin size parameter of 10.

		FFD ffd = new FFD();		//	Algorithms declarations
		FF ff = new FF();
		NF nf = new NF();
		NFD nfd = new NFD();

		MartelloTothBPPLibraryGenerator gen = new MartelloTothBPPLibraryGenerator(bpp);							//	Instance generator declaration

		List<OptimalKnownBPPInstance> l = gen.generateInstances();
		int i=0;
		for (OptimalKnownBPPInstance iBpp : l) {
			if (i<10) i++; else break;			//	Limits to 10 the number of instances solved.
			BPPSol ffSol = ff.solve(iBpp);		//	Solves current instance with First-Fit algorithm.
			BPPSol ffdSol = ffd.solve(iBpp);
			BPPSol nfSol = nf.solve(iBpp);
			BPPSol nfdSol = nfd.solve(iBpp);
			
			System.out.println("Instance Optimal cost : "+iBpp.getOptimalSolution().getCost());		//	Prints instance optimal cost.
			System.out.println(ffSol);																//	Prints solutions & costs.
			System.out.println(ffdSol);
			System.out.println(nfSol);
			System.out.println(nfdSol);
			System.out.println();
		}
	}
```





